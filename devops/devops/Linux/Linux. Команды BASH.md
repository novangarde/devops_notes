
## read

**read** — это встроенная команда в Bash, которая позволяет считывать строки из стандартного ввода (обычно клавиатуры) и сохранять их в переменные для последующей обработки в скриптах.

- **Синтаксис**: `read [опции] переменная1 переменная2 ...`
- **Действие**: Команда читает строку из стандартного ввода и разбивает её на слова. Первое слово присваивается первой переменной, второе — второй, и так далее. Если слов больше, чем переменных, все остальные слова присваиваются последней переменной.

Если после вызова `read` не указать переменную, ввод будет сохранен в специальную переменную **\$REPLY**. Это означает, что если вы просто напишете `read`, без указания переменной, введенные данные будут доступны в `$REPLY`

## test

**Команда test** — это встроенная команда в Bash, которая используется для проверки условий в скриптах. Она позволяет проверять типы файлов, сравнивать строки и числа, а также проверять права доступа к файлам и директориям.

1. **Проверка типа файла**:
    - **-e**: Проверяет, существует ли файл или директория.
    - **-f**: Проверяет, является ли объект обычным файлом.
    - **-d**: Проверяет, является ли объект каталогом.
    - **-L**: Проверяет, является ли объект символьной ссылкой.

2. **Проверка прав доступа**:    
    - **-r**: Проверяет, доступен ли файл для чтения.
    - **-w**: Проверяет, доступен ли файл для записи.
    - **-x**: Проверяет, доступен ли файл для выполнения.

3. **Сравнение файлов**:
    - **-nt**: Проверяет, является ли один файл новее другого.
    - **-ot**: Проверяет, является ли один файл старше другого.

4. **Сравнение строк и чисел**:
    - **=**: Проверяет равенство строк.
    - **!=**: Проверяет неравенство строк.
    - **-eq**, **-gt**, **-lt**, **-ge**, **-le**, **-ne**: Проверяют равенство или неравенство чисел.

Команда `test` может использоваться в двух формах: как `test условие` или как `[ условие ]`. Вторая форма более распространена и удобна для чтения.

```Shell
if test -f "example.txt"; then
  echo "Файл существует."
fi

# Альтернативный синтаксис
if [ -f "example.txt" ]; then
  echo "Файл существует."
fi
```

Команда `test` возвращает код возврата **0**, если условие истинно, и **1**, если условие ложно. Это позволяет использовать ее в условных конструкциях (`if`, `while`, `until`) для управления потоком выполнения скрипта.

## sed

**sed** (Stream Editor) — это потоковый текстовый редактор, который позволяет обрабатывать текстовые данные построчно, не загружая весь файл в память. Это делает его очень эффективным для работы с большими файлами.

**Основные функции sed:**

1. **Поиск и замена**: sed может искать и заменять текст в файлах с помощью регулярных выражений. 
2. **Вставка и удаление**: Позволяет вставлять или удалять строки в файлах.
3. **Редактирование потоков**: Может обрабатывать текстовые потоки, полученные из других команд или файлов.

```Shell
sed OPTIONS... [SCRIPT] [INPUTFILE...]
```

- **OPTIONS**: Опции, такие как `-e` для указания команды, `-n` для подавления вывода, `-i` для изменения файла на месте.
- **SCRIPT**: Команды sed для обработки текста.
- **INPUTFILE**: Файл или файлы, которые будут обработаны.

```Shell
sed 's/old/new/g' input.txt > output.txt
```

**Основные команды sed:**

1. **s/что_заменять/на_что_заменять/опции**: Замена текста.
    - **g**: Глобальная замена (заменяет все вхождения в строке).
    - **p**: Печать строки после замены.
    - **w файл**: Запись измененной строки в файл.
2. **p**: Печать строки.
3. **d**: Удаление строки.
4. **q**: Завершение работы sed.
5. **n**: Чтение следующей строки и продолжение обработки.
6. **N**: Добавление следующей строки в буфер шаблона.
7. **D**: Удаление первой строки из буфера шаблона.
8. **G**: Добавление содержимого дополнительного буфера в буфер шаблона.
9. **y/символы/символы**: Замена символов.

```Shell
# Замена текста
sed 's/old/new/g' file.txt

# Удаление строк, содержащих определенное слово
sed '/word/d' file.txt

# Печать строк, содержащих определенное слово
sed -n '/word/p' file.txt

# Добавление строки в начало файла
sed '1i\Новая строка' file.txt

# Замена символов
sed 'y/abc/123/' file.txt
```

**Опции sed:**

- **-n**: Подавляет вывод по умолчанию.
- **-e**: Указывает команду для выполнения.
- **-f**: Читает команды из файла.
- **-i**: Редактирует файл на месте, создавая резервную копию.
- **-r** или **-E**: Включает поддержку расширенных регулярных выражений (ERE).

## tail

**tail** — это команда в Bash, которая выводит последние строки текстового файла или потока данных. Она часто используется для просмотра последних записей в файлах журналов или отслеживания изменений в файлах в режиме реального времени.

1. **Вывод последних строк**: По умолчанию выводит последние 10 строк файла.
2. **Настройка количества строк**: С помощью опции `-n` можно указать количество строк для вывода.
3. **Вывод байтов**: Опция `-c` позволяет выводить определенное количество байтов с конца файла.
4. **Мониторинг изменений**: Опция `-f` позволяет отслеживать изменения в файле в режиме реального времени.

**Вывод последних 10 строк файла**:

```Shell
tail myfile.txt
```

**Вывод 20 последних строк файла**:

```Shell
tail -n 20 myfile.txt
```

**Мониторинг изменений в файле**:

```Shell
tail -f /var/log/messages
```

## @

Параметр `echo ${m[@]}` выведет все элементы массива `m`, каждый элемент как отдельное слово. Это происходит потому, что `${m[@]}` — это синтаксис для обращения к массивам в bash, где `@` указывает на вывод всех элементов массива.

## $\#

Возвращает количество поданных элементов.

## $?

Выводит код возврата в терминал

```Shell
echo 'Hello, world!'
echo $?
# Эта команда выведет **0**, если команда `echo` выполнится успешно.
```

Коды возврата можно использовать в скриптах для обработки различных сценариев, таких как проверка успешности выполнения команд или обработка ошибок. Например:

```Shell
if [ $? -eq 0 ]; then
    echo "Команда выполнена успешно"
else
    echo "Произошла ошибка"
fi
```

## '' и ""

Разница между **одинарными** и **двойными кавычками** в сценариях командной оболочки Bash заключается в том, как они обрабатывают переменные и специальные символы.

### Одинарные кавычки ('...')

- **Буквальное значение**: Все символы внутри одинарных кавычек обрабатываются буквально, что означает, что раскрытие переменных и подстановка команд не выполняются.
- **Отключение специальных символов**: Все специальные символы, кроме самой одинарной кавычки, теряют свое значение и обрабатываются как обычные символы.

```Shell
VAR=example
echo 'Hello $VAR'
# Вывод: Hello $VAR
```

### Двойные кавычки ("...")

- **Раскрытие переменных**: Переменные внутри двойных кавычек расширяются до своих значений.
- **Подстановка команд**: Подстановка команд с помощью обратных кавычек или синтаксиса `$()` также работает внутри двойных кавычек.
- **Обработка специальных символов**: Некоторые специальные символы, такие как `$`, `\`, имеют особое значение.

```Shell
VAR=example
echo "Hello $VAR"
# Hello example
```

